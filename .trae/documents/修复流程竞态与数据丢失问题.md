# 系统稳健性与流程一致性修复计划

## 1. 流程时序同步 (Fix Race Condition)
解决“人物记录者”滞后于“下一轮写作”的问题。我们将强制主流程等待分析任务完成。

*   **修改 `src/store/useDiscussionStore.ts`**:
    *   在 `processNovelCycle` 的 `revising` 阶段：
        *   将 `analyzeCharacters` 和 `analyzeTasks` 的异步 `.then()` 调用改为 `await Promise.all(...)`。
        *   这将确保在状态流转到 `selecting_option` 之前，人物档案和任务列表已完成更新。
        *   为了优化体验，可以将“生成选项” (`generateOptions`) 与“分析状态”并行执行，取两者最慢的时间。
    *   **引入 Loading 状态**: 确保在等待期间，界面显示“正在更新世界状态...”而非让用户以为卡死。

## 2. 数据合并稳健性 (Fix Data Persistence)
解决随着更新导致旧数据（如旧伤、旧物品）意外丢失的问题。

*   **修改 `src/store/agentConfigStore.ts`**:
    *   **Character Recorder Prompt 增强**:
        *   **全量输出指令**: 明确要求模型“基于【现有档案】，结合【最新章节】，输出**全量**的人物状态”。
        *   **继承指令**: 强调“对于文中未提及但逻辑上依然存在的状态（如旧伤、库存物品），必须原样保留，不得遗漏”。
        *   **显式移除**: 只有当剧情明确表明伤愈或物品消耗时，才从列表中移除。

*   **修改 `src/api/analyzers.ts`**:
    *   **防御性合并逻辑**:
        *   在合并 `bodyStatus` 和 `inventory` 时，不再简单的 `??` 覆盖。
        *   虽然 Prompt 要求全量，但代码层应增加兜底：如果模型返回的 `inventory` 为 `undefined`（非空数组但未定义），则保留旧数据；如果返回空数组 `[]`，则视为清空。
        *   对于 `bodyStatus`，如果模型返回的对象缺少某些旧有的 key（且未被标记为 healed），这比较难判断是遗漏还是愈合。鉴于 Prompt 已强化，我们暂时信任模型的输出（前提是 Prompt 足够强），但可以增加日志记录以便调试。

## 3. 验证计划
*   **时序测试**: 观察定稿后的网络请求，确认 `generateOptions` 和 `analyzeCharacters` 都完成后，界面才显示选项。
*   **数据测试**:
    *   Round 1: 主角获得“手枪”，左臂“擦伤”。
    *   Round 2: 主角只是对话，无战斗。
    *   检查 Round 2 结束后的状态：确认“手枪”和“擦伤”依然存在（未丢失）。
